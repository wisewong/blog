<!DOCTYPE html>
<html >
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>python3 入门 (四) 类与继承 | Sage Wong</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="Python 类 
Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。 
对象可以包含任意数量和类型的数据。 
python类与c++类相似，提供了类的封装，继承、多继承，构造函数、析构函数。 
在python3中，所有类最顶层父类都是object类，与java类似，如果定义类的时候没有写出父类，则obje">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="python3 入门 (四) 类与继承 | Sage Wong">
    <meta name="twitter:description" content="Python 类 
Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。 
对象可以包含任意数量和类型的数据。 
python类与c++类相似，提供了类的封装，继承、多继承，构造函数、析构函数。 
在python3中，所有类最顶层父类都是object类，与java类似，如果定义类的时候没有写出父类，则obje">

    <meta property="og:type" content="article">
    <meta property="og:title" content="python3 入门 (四) 类与继承 | Sage Wong">
    <meta property="og:description" content="Python 类 
Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。 
对象可以包含任意数量和类型的数据。 
python类与c++类相似，提供了类的封装，继承、多继承，构造函数、析构函数。 
在python3中，所有类最顶层父类都是object类，与java类似，如果定义类的时候没有写出父类，则obje">

    
    <meta name="author" content="sage wong">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/avatar-small.png">
    

    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="Sage Wong" href="/atom.xml">
    

    <link rel="canonical" href="http://yoursite.com/2015/10/29/python3 入门 (四) 类与继承/"/>

                 
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/bkc.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 Sage Wong 的主页"><img src="/images/touxiang.jpg" width="80" alt="Sage Wong logo" class="panel-cover__logo logo"></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for Sage Wong">Sage Wong</a></h1>
        
        <hr class="panel-cover__divider">
        <p class="panel-cover__description"></p>
        <hr class="panel-cover__divider panel-cover__divider--secondary">

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="Visit the blog" class="blog-button">Blog</a></li>
            
              <li class="navigation__item"><a href="/aboutme">关于我</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  
  <li class="navigation__item">
    <a href="https://weibo.com/z941030" title="Weibo" target="_blank">
      <i class="social fa fa-weibo"></i>
      <span class="label">Weibo</span>
    </a>
  </li> 


  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/wisewong" title="GitHub" target="_blank">
      <i class="social fa fa-github"></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  <li class="navigation__item">
    <a href="https://twitter.com/mr_xlz" title="Twitter" target="_blank">
      <i class="social fa fa-twitter"></i>
      <span class="label">Twitter</span>
    </a>
  </li>

  

  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class="social fa fa-rss"></i>
      <span class="label">RSS</span>
    </a>
  </li>



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-disabled"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2015-10-29T14:54:06.000Z" class="post-list__meta--date date">2015-10-29</time> &#8226; <span class="post-meta__tags tags">于  </span>
      <span class="page-pv">
       Read <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">python3 入门 (四) 类与继承</h1>
  </header>

  <section class="post">
    <p>Python 类 </p>
<p>Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。 </p>
<p>对象可以包含任意数量和类型的数据。 </p>
<p>python类与c++类相似，提供了类的封装，继承、多继承，构造函数、析构函数。 </p>
<p>在python3中，所有类最顶层父类都是object类，与java类似，如果定义类的时候没有写出父类，则object类就是其直接父类。 </p>
<p>类定义 </p>
<p>类定义语法格式如下： </p>
<pre><code>class ClassName:
    &lt;statement-1&gt;
    .
    .
    .
    &lt;statement-N&gt;
</code></pre><p>类对象  ：创建一个类之后，可以通过类名访问、改变其属性、方法 </p>
<p>实例对象  ：类实例化后，可以使用其属性，可以动态的为实例对象添加属性(类似javascript)而不影响类对象。 </p>
<p>类的属性 </p>
<p>可以使用点(  .  )来访问对象的属性 </p>
<p>也可以使用以下函数的方式来访问属性： </p>
<ul>
<li><p>getattr(obj, name[, default]) : 访问对象的属性 </p>
</li>
<li><p>hasattr(obj,name) : 检查是否存在一个属性 </p>
</li>
<li><p>setattr(obj,name,value) : 设置一个属性。如果属性不存在，会创建一个新属性 </p>
</li>
</ul>
<ul>
<li>delattr(obj, name) : 删除属性 </li>
</ul>
<p>Python内置类属性 </p>
<ul>
<li><p><strong>dict</strong> : 类的属性（包含一个字典，由类的数据属性组成） </p>
</li>
<li><p><strong>doc</strong> :类的文档字符串 </p>
</li>
<li><p><strong>name</strong>: 类名 </p>
</li>
<li><p><strong>module</strong>: 类定义所在的模块（类的全名是’<strong>main</strong>.className’，如果类位于一个导入模块mymod中，那么className.<strong>module</strong> 等于 mymod） </p>
</li>
<li><p><strong>bases</strong> : 类的所有父类构成元素（包含了以个由所有父类组成的元组） </p>
</li>
</ul>
<pre><code>class Person:
    &quot;Person类&quot;
    def __init__(self, name, age, gender):
        print(&apos;进入Person的初始化&apos;)
        self.name = name
        self.age = age
        self.gender = gender
        print(&apos;离开Person的初始化&apos;)

    def getName(self):
        print(self.name)

p = Person(&apos;ice&apos;, 18, &apos;男&apos;)

print(p.name)  # ice
print(p.age)  # 18
print(p.gender)  # 男
print(hasattr(p, &apos;weight&apos;))  # False
# 为p添加weight属性
p.weight = &apos;70kg&apos;
print(hasattr(p, &apos;weight&apos;))  # True
print(getattr(p, &apos;name&apos;))  # ice

print(p.__dict__)  # {&apos;age&apos;: 18, &apos;gender&apos;: &apos;男&apos;, &apos;name&apos;: &apos;ice&apos;}
print(Person.__name__)  # Person
print(Person.__doc__)  # Person类
print(Person.__dict__)  # {&apos;__doc__&apos;: &apos;Person类&apos;, &apos;__weakref__&apos;: &lt;attribute &apos;__weakref__&apos; of &apos;Person&apos; objects&gt;, &apos;__init__&apos;: &lt;function Person.__init__ at 0x000000000284E950&gt;, &apos;getName&apos;: &lt;function Person.getName at 0x000000000284EA60&gt;, &apos;__dict__&apos;: &lt;attribute &apos;__dict__&apos; of &apos;Person&apos; objects&gt;, &apos;__module__&apos;: &apos;__main__&apos;}
print(Person.__mro__)  # (&lt;class &apos;__main__.Person&apos;&gt;, &lt;class &apos;object&apos;&gt;)
print(Person.__bases__)  # (&lt;class &apos;object&apos;&gt;,)
print(Person.__module__)  # __main__
</code></pre><p>类的方法 </p>
<p>在类地内部，使用  def  关键字可以为类定义一个方法，与一般函数定义不同，  类方法必须包含参数  self  ，且为第一个参数。 </p>
<p>类的专有方法： </p>
<ul>
<li><p><strong>init</strong> 构造函数，在生成对象时调用 </p>
</li>
<li><p><strong>del</strong> 析构函数，释放对象时使用 </p>
</li>
<li><p><strong>repr</strong> 打印，转换 </p>
</li>
<li><p><strong>setitem</strong>按照索引赋值 </p>
</li>
<li><p><strong>getitem</strong>按照索引获取值 </p>
</li>
<li><p><strong>len</strong>获得长度 </p>
</li>
<li><p><strong>cmp</strong>比较运算 </p>
</li>
<li><p><strong>call</strong>函数调用 </p>
</li>
<li><p><strong>add</strong>加运算 </p>
</li>
<li><p><strong>sub</strong>减运算 </p>
</li>
<li><p><strong>mul</strong>乘运算 </p>
</li>
<li><p><strong>div</strong>除运算 </p>
</li>
<li><p><strong>mod</strong>求余运算 </p>
</li>
<li><p><strong>pow</strong>称方 </p>
</li>
</ul>
<p><strong>init</strong>()  方法是一种特殊的方法，被称为类的构造函数或初始化方法，当创建了这个类的实例时就会调用该方法，与c++中构造函数类似。只需在自定义的类中重写<strong>init</strong>()方法即可。 </p>
<pre><code>class Person:
    def __init__(self, name, age, gender):
        print(&apos;进入Person的初始化&apos;)
        self.name = name
        self.age = age
        self.gender = gender
        print(&apos;离开Person的初始化&apos;)

    def getName(self):
        print(self.name)

# Person实例对象
p = Person(&apos;ice&apos;, 18, &apos;男&apos;)
print(p.name)
print(p.age)
print(p.gender)
p.getName()

# 进入Person的初始化
# 离开Person的初始化
# ice
# 18
# 男
# ice
</code></pre><p>析构函数 <strong>del</strong> ，<strong>del</strong>在对象消逝的时候被调用，当对象不再被使用时，<strong>del</strong>方法运行： </p>
<p>类的封装 </p>
<p>python通过  变量名命名来  区分属性和方法的访问权限，默认权限相当于c++和java中的public </p>
<p>类的私有属性：  <strong>private_attrs  ：两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问。在类内部的方法中使用时  self.</strong>private_attrs  。 </p>
<p>类的私有方法：  <strong>private_method  ：两个下划线开头，声明该方法为私有方法，不能在类地外部调用。在类的内部调用  self.</strong>private_methods </p>
<p>虽然python不允许实例化的类访问私有数据，但可以使用  object._className__attrName  访问属性。其实python内部私有化的实现只是将attrName属性变为了_className__attrName而已 </p>
<pre><code>class Demo:
    __id = 123456

    def getId(self):
        return self.__id

temp = Demo()
# print(temp.__id)  # 报错 AttributeError: &apos;Demo&apos; object has no attribute &apos;__id&apos;
print(temp.getId())  # 123456
print(temp._Demo__id)  # 123456
</code></pre><p>类的继承 </p>
<p>面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过继承机制。继承完全可以理解成类之间的类型和子类型关系。 </p>
<p>需要注意的地方：  继承语法  class 派生类名（  基类名  ）：//… 基类名写作括号里，基本类是在类定义的时候，在元组之中指明的。 </p>
<p>在python中继承中的一些特点： </p>
<ul>
<li>1：在继承中基类的构造（<strong>init</strong>()方法）不会被自动调用，它需要在其派生类的构造中亲自专门调用。使用super().<strong>init</strong>()或parentClassName.<strong>init</strong>() </li>
<li>2：在调用基类的方法时，需要加上基类的类名前缀，且需要带上self参数变量。区别于在类中调用普通函数时并不需要带上self参数 </li>
<li>3：Python总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。 </li>
</ul>
<p>如果在继承元组中列了一个以上的类，那么它就被称作”多重继承” 。 </p>
<p>语法： </p>
<p>派生类的声明，与他们的父类类似，继承的基类列表跟在类名之后，如下所示： </p>
<p>多态 </p>
<p>如果父类方法的功能不能满足需求，可以在子类重写父类的方法。实例对象调用方法时会调用其对应子类的重写后的方法 </p>
<p><a href="http://www.cnblogs.com/z941030/" target="_blank" rel="noopener"> 博客园博客:欠扁的小篮子 </a>   </p>

  </section>

</article>

<section class="read-more">
           
    
               
            <div class="read-more-item">
                <span class="read-more-item-dim">Newer Post</span>
                <h2 class="post-list__post-title post-title"><a href="/2015/10/31/动态规划之矩阵连乘/" title="动态规划之矩阵连乘">动态规划之矩阵连乘</a></h2>
                <p class="excerpt">
                
                给定n个矩阵｛A  1  ,A  2  ,…,A  n  ｝，其中Ai与A  i+1  是可乘的，i=1,2 ,…,n-1。如何确定计算矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积需要的数乘次数最少。 
例如： 
A  1  ={30x35} ; A  2  ={35x15} ;A  3  ={
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2015-10-31T02:06:32.000Z" class="post-list__meta--date date">2015-10-31</time> &#8226; <span class="post-list__meta--tags tags">于 </span><a class="btn-border-small" href="/2015/10/31/动态规划之矩阵连乘/">继续阅读</a></div>
                           
            </div>
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">Older Post</span>
                <h2 class="post-list__post-title post-title"><a href="/2015/10/25/动态规划之最长公共子序列(LCS)/" title="动态规划之最长公共子序列(LCS)">动态规划之最长公共子序列(LCS)</a></h2>
                <p class="excerpt">
                
                最长公共子序列(LCS,Longest Common Subsequence)。其定义是，一个序列 S ，如果分别是两个或多个已知序列的子序列，且是所有符合此条件序列中最长的，则 S 称为已知序列的最长公共子序列。而最长公共子串(要求连续)和最长公共子序列是不同的。 
设X(m)={x(1), x(
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2015-10-25T15:44:57.000Z" class="post-list__meta--date date">2015-10-25</time> &#8226; <span class="post-list__meta--tags tags">于 
  <a class="tag-link" href="/tags/LCS/">LCS</a>, <a class="tag-link" href="/tags/算法设计与分析/">算法设计与分析</a>
</span><a class="btn-border-small" href="/2015/10/25/动态规划之最长公共子序列(LCS)/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

  

            <footer class="footer">
    <span class="footer__copyright">
        &copy; 2019 sage wong - 本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
       
    </span>
    <span class="footer__copyright">
             - 基于 <a href="http://hexo.io">Hexo</a> 搭建，使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题，由<a href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
         </span>
       
    
    
</footer>


        </div>
    </div>

     
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-78918255-1', 'auto');
	ga('send', 'pageview');
</script>

    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?9cdad07c755fa23f6aced510c6760e87";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
