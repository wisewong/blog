<!DOCTYPE html>
<html >
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>Java NIO | Sage Wong</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="了解java的NIO，需要先了解同步异步以及阻塞非阻塞的概念，  同步/异步，阻塞/非阻塞 
NIO就是采用的同步非阻塞这种组合方式。或简单一点，采用的是IO复用的策略，可以使用一个线程管理多个IO连接。 
BIO常见使用方式传统的BIO是同步阻塞的方式，因此，在服务器中常见的使用方式是： 

来一个请求创建一个线程，阻塞的等待网络IO的数据。 


使用一个线程池，来一个请求就从线程池里取出来一">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Java NIO | Sage Wong">
    <meta name="twitter:description" content="了解java的NIO，需要先了解同步异步以及阻塞非阻塞的概念，  同步/异步，阻塞/非阻塞 
NIO就是采用的同步非阻塞这种组合方式。或简单一点，采用的是IO复用的策略，可以使用一个线程管理多个IO连接。 
BIO常见使用方式传统的BIO是同步阻塞的方式，因此，在服务器中常见的使用方式是： 

来一个请求创建一个线程，阻塞的等待网络IO的数据。 


使用一个线程池，来一个请求就从线程池里取出来一">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Java NIO | Sage Wong">
    <meta property="og:description" content="了解java的NIO，需要先了解同步异步以及阻塞非阻塞的概念，  同步/异步，阻塞/非阻塞 
NIO就是采用的同步非阻塞这种组合方式。或简单一点，采用的是IO复用的策略，可以使用一个线程管理多个IO连接。 
BIO常见使用方式传统的BIO是同步阻塞的方式，因此，在服务器中常见的使用方式是： 

来一个请求创建一个线程，阻塞的等待网络IO的数据。 


使用一个线程池，来一个请求就从线程池里取出来一">

    
    <meta name="author" content="sage wong">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/avatar-small.png">
    

    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="Sage Wong" href="/atom.xml">
    

    <link rel="canonical" href="http://yoursite.com/2018/03/28/Java NIO/"/>

                 
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/bkc.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 Sage Wong 的主页"><img src="/images/touxiang.jpg" width="80" alt="Sage Wong logo" class="panel-cover__logo logo"></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for Sage Wong">Sage Wong</a></h1>
        
        <hr class="panel-cover__divider">
        <p class="panel-cover__description"></p>
        <hr class="panel-cover__divider panel-cover__divider--secondary">

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="Visit the blog" class="blog-button">Blog</a></li>
            
              <li class="navigation__item"><a href="/aboutme">关于我</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  
  <li class="navigation__item">
    <a href="https://weibo.com/z941030" title="Weibo" target="_blank">
      <i class="social fa fa-weibo"></i>
      <span class="label">Weibo</span>
    </a>
  </li> 


  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/wisewong" title="GitHub" target="_blank">
      <i class="social fa fa-github"></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  <li class="navigation__item">
    <a href="https://twitter.com/mr_xlz" title="Twitter" target="_blank">
      <i class="social fa fa-twitter"></i>
      <span class="label">Twitter</span>
    </a>
  </li>

  

  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class="social fa fa-rss"></i>
      <span class="label">RSS</span>
    </a>
  </li>



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-disabled"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2018-03-28T06:22:48.000Z" class="post-list__meta--date date">2018-03-28</time> &#8226; <span class="post-meta__tags tags">于 
  <a class="tag-link" href="/tags/Java/">Java</a>, <a class="tag-link" href="/tags/NIO/">NIO</a>
 </span>
      <span class="page-pv">
       Read <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">Java NIO</h1>
  </header>

  <section class="post">
    <p>了解java的NIO，需要先了解同步异步以及阻塞非阻塞的概念， <a href="https://blog.csdn.net/u013805360/article/details/79393252" target="_blank" rel="noopener"> 同步/异步，阻塞/非阻塞 </a></p>
<p>NIO就是采用的同步非阻塞这种组合方式。或简单一点，采用的是IO复用的策略，可以使用一个线程管理多个IO连接。 </p>
<h1 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h1><h2 id="常见使用方式"><a href="#常见使用方式" class="headerlink" title="常见使用方式"></a>常见使用方式</h2><p>传统的BIO是同步阻塞的方式，因此，在服务器中常见的使用方式是： </p>
<ul>
<li>来一个请求创建一个线程，阻塞的等待网络IO的数据。 </li>
</ul>
<ul>
<li>使用一个线程池，来一个请求就从线程池里取出来一个线程，阻塞的等待网络IO的数据。 </li>
</ul>
<p>两种方式的图例： </p>
<p><img src="https://img-blog.csdn.net/20180328141631333" alt=""> <img src="https://img-blog.csdn.net/20180328141640321" alt=""></p>
<h2 id="BIO面临的问题"><a href="#BIO面临的问题" class="headerlink" title="BIO面临的问题"></a>BIO面临的问题</h2><p>上面的方案可能会出现的问题是 </p>
<ul>
<li>针对第一种方式，如果短时间内qps过高，可能会导致线程数过多，拖垮服务器。 </li>
</ul>
<ul>
<li>针对第二种方式，现在一般用的http1.1支持长连接，若系统中有大量的长连接没有释放，依然在阻塞的等待网络IO，就会导致线程池资源慢慢被消耗调，最终可能导致线程池满无法提供服务。 </li>
</ul>
<p>总结一下，上述两点问题的原因，其共同点是可能会有很多的空闲线程阻塞的等待IO，导致服务器以各种表现形式没有办法继续对外提供服务。 </p>
<h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><h2 id="NIO的IO多路复用"><a href="#NIO的IO多路复用" class="headerlink" title="NIO的IO多路复用"></a>NIO的IO多路复用</h2><p>因此，如果是同步非阻塞的方式，可以只需要一个线程，管理多个IO连接。一旦有连接可以读/写，才开启一个线程进行读/写、执行相应的操作。如下： </p>
<p><img src="https://img-blog.csdn.net/20180328141733428" alt=""></p>
<h2 id="Java中的NIO"><a href="#Java中的NIO" class="headerlink" title="Java中的NIO"></a>Java中的NIO</h2><p>原理接说到这里，下面看一下jdk中NIO的实现和用法。jdk中的NIO的实现，主要几个部分是Channel（通道），Buffer（缓冲区），Selector（选择器）。 </p>
<ul>
<li>Channel提供从文件、网络读取数据的通道，但是读取或写入的数据都必须经由Buffer。通道是双向的，通过一个Channel既可以进行读，也可以进行写 </li>
</ul>
<ul>
<li>Buffer，故名思意，缓冲区，实际上是一个容器，是一个连续数组。服务端接收数据必须通过Channel将数据读入到Buffer中，然后再从Buffer中取出数据来处理。 </li>
</ul>
<ul>
<li>Selector类是NIO的核心类，Selector能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的响应处理。 </li>
</ul>
<p>在一个基于NIO的IO多路复用的具体应用场景中，它们之间的关系可能是这样的： </p>
<p><img src="https://img-blog.csdn.net/20180328141837110" alt=""></p>
<p>其中，一个线程管理一个Selector，而一个Selector管理多个Channel，被管理的Channel需要在该Selector上注册自己感兴趣的事件，如Accept，Read，Write等。 </p>
<p>每个Channel对应一个缓冲区Buffer，每次Channel中有数据可以读写的时候，就读写到缓冲区中。然后程序再对缓冲区进行操作。 </p>
<p>这样一来，只是用一个单线程就可以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用相应的方法或者线程来进行读写、操作，大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，并且避免了多个空闲连接的多线程之间的上下文切换导致的开销。 </p>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>既然NIO是非阻塞，其实就是  把阻塞的位置从系统的CPU层面提到了程序层面，  那么当Channel中注册的感兴趣的事件就绪时，Selector需要通过某种策略得知Channel数据已经就绪，可以采用轮询、事件驱动等方式。这里就封装成了Selector的select方法，返回值是已经就绪的通道的数量。 </p>
<p>当Selector得知有通道对其感兴趣的事件就绪时，就取出所有已经就绪的通道，进行读写或者其它操作。Selector的 selectedKeys()方法就封装了取出所有就绪的通道的事件，返回值是一个SelectionKey的集合。SelectionKey中封装了一个Channel与selector的对应关系、Channel感兴趣的事件、Channel哪种事件已经就绪的判断(isReadable、isWritable等)。 </p>
<h4 id="Selector的工作方式"><a href="#Selector的工作方式" class="headerlink" title="Selector的工作方式"></a>Selector的工作方式</h4><p>看一下Selector的工作方式： </p>
<p><img src="https://img-blog.csdn.net/20180328141909170" alt=""></p>
<p>流程总结如下： </p>
<ul>
<li>通过 Selector.open() 打开一个 Selector. </li>
</ul>
<ul>
<li>将 Channel 注册到 Selector 中, 并设置需要监听的事件(interest set) </li>
</ul>
<ul>
<li>不断重复: </li>
</ul>
<ul>
<li>调用 select() 方法，阻塞获取到就绪通道 </li>
<li>调用 selector.selectedKeys() 获取 selected keys </li>
<li>迭代每个selected keys，对每个 selected key: </li>
</ul>
<ol>
<li>从 selected key 中获取 对应的 Channel 和附加信息(如果有的话) </li>
<li>判断是哪些 IO 事件已经就绪了, 然后处理它们. 如果是 OP_ACCEPT 事件, 则获取 SocketChannel, 并将它设置为 非阻塞的, 然后将这个 Channel 注册到 Selector 中.，如果是读/写事件，则进行读写操作。 </li>
<li>根据需要更改 selected key 的监听事件. </li>
<li>将已经处理过的 key 从 selected keys 集合中删除. </li>
</ol>
<p>需要注意的一点是，图中第4步中的select方法，有几个重载的方法： </p>
<p>select()   阻塞到至少有一个通道在你注册的事件上就绪了。 </p>
<p>select(long timeout)    和select()一样，但最长阻塞事件为timeout毫秒。 </p>
<p>selectNow()  非阻塞，立即返回结果，如果没有已就绪事件，直接返回0。 </p>
<h4 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h4><p>由一个线程管理一个Selector，一个Selector可以管理多个通道Channel。当调用Selector的select方法时，会阻塞的等待操作系统返回已经就绪的IO通道。这里用到的技术是IO多路复用，从而实现了同步非阻塞，解决了一个请求一个线程一直在阻塞的问题。因为一个selector线程管理了多个连接、通道，select一旦拿到有准备就绪的通道，无论是在本线程内对其做读写操作，还是交给一个其他线程去做读写操作，这个时候Selector所在的线程其实一直是可用的，并没有因为其他通道还未就绪而一直空闲。 </p>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>因为我们的Selector线程是去主动问操作系统有没有IO已经就绪，若就绪则进行读写(用户空间↔内核空间数据copy)，而不是操作系统把数据准备好之后(用户空间↔内核空间数据copy完成)再来通知我们的程序。所以说这里的IO是同步的。 </p>
<h4 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h4><p>因为Selector线程对于每一个通道的数据，并没有等待数据就绪，而是直接返回，所以这里的IO是非阻塞的。上面提到的阻塞等待，等待的是这个Selector所管理的所有通道。也因此一个Selector线程可以管理多个IO通道。 </p>
<p>综上所述，Java的NIO是以Selector为核心的，基于同步非阻塞的IO多路复用。 </p>
<h4 id="OS的IO多路复用"><a href="#OS的IO多路复用" class="headerlink" title="OS的IO多路复用"></a>OS的IO多路复用</h4><p>那么，Selector是如何得知哪些通道是就已经就绪了呢？这里涉及到的系统调用是select，poll，epoll。既然我们的程序使用了IO多路复用实现了一个线程管理多个IO，那么操作系统告诉我们已就绪的IO通道时，底层是否也采用了IO多路复用呢？操作系统的IO多路复用(IO multiplexing)就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。 </p>
<p>所以总结来说，就是我们的用户线程使用IO多路复用，管理多个IO通道，一旦有通道就绪，就进行读写。而我们的操作系统同样采用了IO多路复用，一旦有socket数据准备就绪，就通知我们的的用户线程。 </p>
<h4 id="select-的实现"><a href="#select-的实现" class="headerlink" title="select()的实现"></a>select()的实现</h4><p>翻一番Selector实现类的源码，select()方法其实还是调用了select(long timeout)方法。 </p>
<pre><code>public int select() throws IOException {
    return this.select(0L);
}


public int select(long timeout) throws IOException {
    if (timeout &lt; 0L) {
        throw new IllegalArgumentException(&quot;Negative timeout&quot;);
    } else {
        return this.lockAndDoSelect(timeout == 0L ? -1L : timeout);
    }
}


public int selectNow() throws IOException {
    return this.lockAndDoSelect(0L);
}
</code></pre><p>看得出来，select阻塞获取操作系统就绪通道的关键的实现在于lockAndDoSelect方法中：    </p>
<pre><code>private int lockAndDoSelect(long var1) throws IOException {
    synchronized(this) {
        if (!this.isOpen()) {
            throw new ClosedSelectorException();
        } else {
            Set var4 = this.publicKeys;
            int var10000;
            synchronized(this.publicKeys) {
                Set var5 = this.publicSelectedKeys;
                synchronized(this.publicSelectedKeys) {
                    var10000 = this.doSelect(var1);
                }
            }

            return var10000;
        }
    }
}
</code></pre><p>加了两个锁，然后会调用一个doSelect方法。doSelect方法由子类实现，有PollSelectorImpl、EPollSelectorImpl。他们实现doSelect时分别调用了本地方法poll0、epollWait，分别对应操作系统的poll、epoll策略。 </p>
<p>在调用Selector的open方时，就已经根据操作系统、内核版本决定了采用哪种IO复用策略，简单看一下 <a href="http://sun.nio.ch/" target="_blank" rel="noopener"> sun.nio.ch </a> .DefaultSelectorProvider#create里Selector的创建： </p>
<pre><code>public static SelectorProvider create() {
    String var0 = (String)AccessController.doPrivileged(new GetPropertyAction(&quot;os.name&quot;));
    if (var0.equals(&quot;SunOS&quot;)) {
        return createProvider(&quot;sun.nio.ch.DevPollSelectorProvider&quot;);
    } else {
        return (SelectorProvider)(var0.equals(&quot;Linux&quot;) ? createProvider(&quot;sun.nio.ch.EPollSelectorProvider&quot;) : new PollSelectorProvider());
    }
}
</code></pre><p>如果是Linux系统的话，使用的是操作系统的epoll 的策略 </p>
<p>对于操作系统来说： </p>
<p>epoll：如果有IO已经就绪，会给用户线程返回所有就绪的事件，可以对这个就绪的IO通道进行读写。 </p>
<p>poll：得到有就绪的IO时，需要遍历去查询哪些IO是已就绪的，然后返回给用户线程去读写。 </p>
<p>参考文章： </p>
<p><a href="http://ifeve.com/overview/" target="_blank" rel="noopener"> Java NIO系列教程 </a></p>
<p><a href="http://www.cnblogs.com/dolphin0520/p/3919162.html" target="_blank" rel="noopener"> Java NIO：NIO概述 </a></p>
<p><a href="https://www.jianshu.com/p/07d3d421a877" target="_blank" rel="noopener"> Java IO &amp; NIO &amp; NIO2 </a></p>
<p><a href="https://segmentfault.com/a/1190000011358146" target="_blank" rel="noopener"> Java 网络 IO 模型 </a></p>
<p><a href="http://www.cnblogs.com/duanxz/p/6782783.html" target="_blank" rel="noopener"> Java NIO系列教程（六） 多路复用器Selector </a></p>
<p><a href="https://blog.csdn.net/anxpp/article/details/51512200" target="_blank" rel="noopener"> Java 网络IO编程总结（BIO、NIO、AIO均含完整实例代码） </a></p>
<p><a href="http://lixiaohui.iteye.com/blog/2345355" target="_blank" rel="noopener"> Java NIO 反应堆模式简单模型 </a></p>
<p><a href="https://zhuanlan.zhihu.com/p/27441342" target="_blank" rel="noopener"> Java NIO(7): Epoll版的Selector </a></p>
<p><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener"> Linux IO模式及 select、poll、epoll详解 </a></p>

  </section>

</article>

<section class="read-more">
           
    
               
            <div class="read-more-item">
                <span class="read-more-item-dim">Newer Post</span>
                <h2 class="post-list__post-title post-title"><a href="/2018/04/11/Tomcat NIO/" title="Tomcat NIO">Tomcat NIO</a></h2>
                <p class="excerpt">
                
                说起Tomcat的NIO，不得不提的就是Connector这个Tomcat组件。Connector是Tomcat的连接器，其主要任务是负责处理收到的请求，并创建一个Request和Response的对象，然后用一个线程用于处理请求，Connector会把Request和Response对象传递给该线
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2018-04-11T07:00:23.000Z" class="post-list__meta--date date">2018-04-11</time> &#8226; <span class="post-list__meta--tags tags">于 </span><a class="btn-border-small" href="/2018/04/11/Tomcat NIO/">继续阅读</a></div>
                           
            </div>
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">Older Post</span>
                <h2 class="post-list__post-title post-title"><a href="/2018/03/20/Java线程的几种状态/" title="Java线程的几种状态">Java线程的几种状态</a></h2>
                <p class="excerpt">
                
                java.lang.Thread.State中定义的集中Java线程的状态： 
/**
 * A thread state.  A thread can be in one of the following states:
 * &amp;lt;ul&amp;gt;
 * &amp;lt;li&amp;gt;{@link #NEW
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2018-03-20T09:31:20.000Z" class="post-list__meta--date date">2018-03-20</time> &#8226; <span class="post-list__meta--tags tags">于 </span><a class="btn-border-small" href="/2018/03/20/Java线程的几种状态/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

  

            <footer class="footer">
    <span class="footer__copyright">
        &copy; 2019 sage wong - 本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
       
    </span>
    <span class="footer__copyright">
             - 基于 <a href="http://hexo.io">Hexo</a> 搭建，使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题，由<a href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
         </span>
       
    
    
</footer>


        </div>
    </div>

     
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-78918255-1', 'auto');
	ga('send', 'pageview');
</script>

    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?9cdad07c755fa23f6aced510c6760e87";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
